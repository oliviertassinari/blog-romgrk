---
title: 'The problem with functional components'
description: 'romgrk ranting about the deprecation of class components'
pubDate: 'Sep 21 2023'
---
import { ExampleStack, ExamplePerformance } from '../../components/client/posts/react-function-components.tsx'


Over the last years, with the introduction of functional components and hooks, React has gradually been phasing out class components. Although I appreciate the introduction of functional components for their simplicity & conciseness, I think that removing class components completely was the wrong decision.

Let's look at an example. Below we have the same draft for a `Selector` component in functional and class versions.

<div class="row mb-1">

```tsx
class Selector extends Component {
  // private fields
  id = cuid()
  ref = createRef()
  position = { x: 0, y: 0}

  // state
  state = {
    open: false,
    loading: false,
    disabled: false,
    selectedIndex: -1,
  }

  // methods
  open() {}
  close() {}
  select(index) {}
  focus() {}

  // result
  render() {
    return (
      /* ... */
    )
  }
}
```

```tsx
function Selector(props) {
  // private fields
  const id = useRef(cuid())
  const ref = useRef()
  const position = useRef({ x: 0, y: 0 })

  // state
  const [open, setOpen] = useState(false)
  const [loading, setLoading] = useState(false)
  const [disabled, setDisabled] = useState(false)
  const [selectedIndex, setSelectedIndex] = useState(-1)

  // methods
  const open = useCallback(() => {}, [])
  const close = useCallback(() => {}, [])
  const select = useCallback((index) => {}, [])
  const focus = useCallback(() => {}, [])

  // result
  return (
    /* ... */
  )
}
```

</div>

### Issue #1: Readability is worst

Whereas the class version uses idiomatic javascript syntax, the functional one replicates the **same code structure** by mashing every field, state and method into one huge giant function, where method declaration, field initialization and UI rendering intermingle into one ungodly mess.

Add to that the fact that you need to wrap everything in `React.useState`, `React.useMemo` and `React.useCallback`. Every field. Every method. Everywhere.

And the worst? I lied above. To be 100% equivalent you'd need to wrap with `forwardRef` and expose the methods with `useImperativeHandle`:

```tsx
const Selector = forwardRef(function Selector(props, ref) {
  /* same as above: fields, state, methods */

  useImperativeHandle(ref, () => ({
    open,
    close,
    select,
    focus,
  }), [])

  /* same as above: result */
})

```

### Issue #2: DX is worst

<div class="if-firefox text-warning">NOTE: You appear to be on firefox. This section doesn't apply for your browser.</div>

Let's say you're debugging some bug that happens in response to an event. The handler calls down some function. Which calls another. Few levels more. You know where the bug happens. You've set your `debugger` breakpoint, deep down in the stack. What does your call stack look like?

<ExampleStack client:load />

Yup. `useCallback` prevents the function from being assigned directly to a variable, so it's anonymous and the engine can't guess it's name*. This is what you get in the devtools everytime you look at your call stack. Wanna figure what calls resulted in this bug? Go look at every entry of the stack manually.

*\* SpiderMonkey is the only exception :O V8 and JSC can't.*

### Issue #3: Performance is worst

This one is obvious. Every time your component re-renders, it needs to make:

```tsx
/* +1 allocation: inline object */
const cache = useRef({})

/* +1 allocation: return array */
const [state, setState] = useState(false)

/* +2 allocations: inline closure, dependency array */
const method = useCallback(() => {}, [])

/* +2 allocations: inline closure, dependency array */
const derived = useMemo(() => {}, [props.data])
```

Don't think it matters enough?

<ExamplePerformance client:load />
