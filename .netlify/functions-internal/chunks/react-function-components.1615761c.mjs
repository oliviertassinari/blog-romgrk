const id = "react-function-components.mdx";
						const collection = "blog";
						const slug = "react-function-components";
						const body = "import RandomPlant from '../../components/client/RandomPlant/RandomPlant.tsx'\nimport { ExampleStack, ExamplePerformance } from '../../components/client/posts/react-function-components.tsx'\n\n\nOver the last years, with the introduction of functional components and hooks, React has gradually been phasing out class components. Although I appreciate the introduction of functional components for their simplicity & conciseness, I think that <mark title=\"read the addendum\">removing class components</mark> was the wrong decision.\n\nLet's look at an example. Below we have equivalent drafts for a `Selector` component in functional and class versions.\n\n<div class=\"row mb-1\">\n\n```tsx\nclass Selector extends Component {\n  // fields\n  id = cuid()\n  ref = createRef()\n  position = { x: 0, y: 0}\n\n  // state\n  state = {\n    open: false,\n    loading: false,\n    disabled: false,\n    selectedIndex: -1,\n  }\n\n  // methods\n  open() {}\n  close() {}\n  select(index) {}\n  focus() {}\n\n  // result\n  render() {\n    return (\n      /* ... */\n    )\n  }\n}\n```\n\n```tsx\nfunction Selector(props) {\n  // fields\n  const id = useRef(cuid())\n  const ref = useRef()\n  const position = useRef({ x: 0, y: 0 })\n\n  // state\n  const [open, setOpen] = useState(false)\n  const [loading, setLoading] = useState(false)\n  const [disabled, setDisabled] = useState(false)\n  const [selectedIndex, setSelectedIndex] = useState(-1)\n\n  // methods\n  const open = useCallback(() => {}, [])\n  const close = useCallback(() => {}, [])\n  const select = useCallback((index) => {}, [])\n  const focus = useCallback(() => {}, [])\n\n  // result\n  return (\n    /* ... */\n  )\n}\n```\n\n</div>\n\n### Issue #1: Readability is worst\n\nWhereas the class version uses idiomatic standard javascript syntax, the functional one replicates the **same code structure** by mashing every field, state and method into one huge giant function, where method declaration, field initialization and UI rendering intermingle into one ungodly mess. What tells me there isn't a `if (something) return <Haha />` in-between one of those fields or methods? Nothing. I need to scan everything to know where the rendering part really begins.\n\nAnd you need to wrap everything in `useState`, `useMemo` and `useCallback`. Every field. Every method. Everywhere.\n\nAnd the worst? I lied above. To be 100% equivalent you'd need to wrap with `forwardRef` and expose the methods with `useImperativeHandle`:\n\n```tsx\nconst Selector = forwardRef(function Selector(props, ref) {\n  /* same as above: fields, state, methods */\n\n  useImperativeHandle(ref, () => ({\n    open,\n    close,\n    select,\n    focus,\n  }), [])\n\n  /* same as above: result */\n})\n\n```\n\n### Issue #2: DX is worst\n\n<div class=\"if-firefox text-warning\">NOTE: You appear to be on firefox. This section doesn't apply for your browser.</div>\n\nLet's say you're debugging some bug that happens in response to an event. The handler calls down some function. Which calls another. Few levels more. You know where the bug happens. You've set your `debugger` breakpoint, deep down in the stack. What does your call stack look like?\n\n<ExampleStack client:load />\n\nYup. `useCallback` prevents the function from being assigned directly to a variable, so it's anonymous and the engine can't guess it's name*. This is what you get in the devtools everytime you look at your call stack. Wanna figure what calls resulted in this bug? Go look at every entry of the stack manually.\n\n*\\* SpiderMonkey is the only exception :O V8 and JSC can't.*\n\n### Issue #3: Performance is worst\n\nThis one is obvious. Every time your component re-renders, it needs to make:\n\n```tsx\n/* +1 allocation: return array */\nconst [state, setState] = useState(false)\n\n/* +2 allocations: inline closure, dependency array */\nconst method = useCallback(() => {}, [])\n\n/* +2 allocations: inline closure, dependency array */\nconst derived = useMemo(() => {}, [props.data])\n```\n\nIn addition to those, which are \"React's fault\", there are also just more allocations by default because there is no differentiation between initialization (like you know, a `constructor()`) and rendering, so people keep doing allocations like this one:\n\n```tsx\n/* +1 allocation: inline object */\nconst position = useRef({ x: 0, y: 0})\n```\n\nAnyway let's test it with my poor man's implementation of react hooks. It's accurate in terms of performance overhead, the react hooks implementation also uses a linked list (click Show Context to see the implementation).\n\n<ExamplePerformance client:load />\n\nAlright, I'll admit that the use-case (3000 components, render 5x) is a bit of a stretch, and that the impact for the large majority of applications is irrelevant. But in some cases, it does. You're running this on a fast computer, what would be the result on a low-end device? What happens when you do get to those stretching use-cases? Then you don't have a choice but to use the wasteful functional components.\n\nOf course if you have a (real) functional component that is just a pure function `Component :: props -> UI` with no state & hooks, then for sure the functional one is faster. Functional components do have a place, they're excellent for simple use-cases. But there's more than just simple use-cases in life..\n\n## Final notes\n\nI wish React would keep class components in. I don't have much hope though. The tendency I've seen from the library in the last years is that they try to actively make it impossible to shoot yourself in the foot (see `dangerouslySetInnerHTML` or `componentWillReceiveProps`) and to have One Right Way to do things. Which makes sense, from their point of view. They're maintaining a library with a huge reach, so the biggest problem from their perspective is to ensure that most people are using the library correctly, and that means making things as simple as possible so those with less experience can use it correctly. They basically baby-proof it. The thing is, by doing so they make it harder to solve hard problems.\n\n<br/>\n<RandomPlant />\n<br/>\n<br/>\n\n<hr/>\n\n### Addendum: *\"but they're not removing class components\"*\n\nAny code written with hooks cannot be used from class components, therefore it's not possible to write new code with classes because the default style is functional components. The maintainers have also stopped making things usable. It's not possible to use more than one context in a class component (at least in an ergonomic way). And all the new improvements (e.g. `useEffect`: running something when a specific set of state/props changes) are also not included in the class components API. So yes, they're removing them.\n";
						const data = {title:"The problem with functional components",description:"romgrk ranting about the deprecation of class components",pubDate:new Date(1695268800000)};
						const _internal = {
							type: 'content',
							filePath: "/home/romgrk/src/blog-romgrk/src/content/blog/react-function-components.mdx",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
